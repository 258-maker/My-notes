# 独立按键原理
- 单片机上电的时候，所有的IO口默认为高电平，看原理图可以发现几个按键接地，当按下按键后，电路导通，此时就为低电平，即P3_1= =0(此处以P3_1举例)；
- 寄存器会写一个值送到IO口上，同理寄存器也会检测IO口的电平并读回寄存器；
- **总结：寄存器通过检测高低电平检测按键是否被按下；**

# 绘制独立按键Proteus
- 切到英文输入法按a，弹出弹窗，在字符串栏输入net=P3#，可进行网络标号
![](https://github.com/258-maker/picx-images-hosting/raw/master/20260206/屏幕截图-2026-02-06-131044.5q7xm5fy71.webp)

# 独立按键控制LED亮灭
- 单独控制其中一个LED，如P2_0=0(亮),P2_0=1（灭）;
```c
#include <REGX52.H>
void main()
{
	while(1)
	{
		 if(P3_1==0)
		 {
			P2_0=0;
		 }
		 else
		 {
			P2_0=1;
		 }
	}
}

```

# 一些语法

| 类别  | 运算符  | 意义   | 类别  | 运算符  | 意义   |
| :-- | :--- | :--- | :-- | :--- | :--- |
| 算术  | `+`  | 加    | 逻辑  | `&&` | 逻辑与  |
| 算术  | `-`  | 减    | 逻辑  | \|\| | 逻辑或  |
| 算术  | `*`  | 乘    | 逻辑  | `!`  | 逻辑非  |
| 算术  | `/`  | 除    | 位运算 | `<<` | 按位左移 |
| 算术  | `%`  | 取余   | 位运算 | `>>` | 按位右移 |
| 算术  | `=`  | 赋值   | 位运算 | `&`  | 按位与  |
| 判断  | `>`  | 大于   | 位运算 |  \|  | 按位或  |
| 判断  | `>=` | 大于等于 | 位运算 | `^`  | 按位异或 |
| 判断  | `<`  | 小于   | 位运算 | `~`  | 按位取反 |
| 判断  | `<=` | 小于等于 |     |      |      |
| 判断  | `==` | 等于   |     |      |      |
| 判断  | `!=` | 不等于  |     |      |      |
- &：有0则0；    |：有1则1；   ^:两个数据相同时输出0，不同时输出1；

| 运算表达式                    | 结果        |
| ------------------------ | --------- |
| 0011 1100 << 1           | 0111 1000 |
| 0011 1100 >> 2           | 0000 1111 |
| 0001 1000 & 0010 1010    | 0000 1000 |
| 0001 1000  \|  0010 1010 | 0011 1010 |
| 0001 1000 ^ 0010 1010    | 0011 0010 |
| ~0001 1000               | 1110 0111 |
# 按键的抖动
> 对于机械开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个开关在闭合时不会马上稳定地接通，在断开时也不会一下子断开，所以在开关闭合及断开的瞬间会伴随一连串的抖动

![](https://github.com/258-maker/picx-images-hosting/raw/master/20260206/IMG_20260206_142059.54y9zulo19.webp)
- 消除抖动的方法，软件消抖（可设置控制延时时间）：
```c
#include <REGX52.H>
void Delay(unsigned int xms)	//@11.0592MHz
{
	unsigned char data i, j;
	while(xms)
	{
		i = 2;
		j = 199;
		do
		{
			while (--j);
		} while (--i);
		xms--;
	}
}
void main()
{
	while(1)
	{
		if(P3_1==0)
		{
			Delay(20);//按下消抖动
			while(P3_1==0);//监测按下后是否松手，松手才操作，像鼠标一样
			Delay(20);//松开消抖动
			
			P2_0=~P2_0;
		}
	}
}

```
# 独立按键控制LED显示二进制
- 主函数调用延时函数，实现LED灯亮灭，P3_1为控制按钮，P2控制灯亮灭，LEDNum控制移动：
```c
#include <REGX52.H>
void Delay(unsigned int xms)	//@11.0592MHz
{
	unsigned char data i, j;
	while(xms)
	{
		i = 2;
		j = 199;
		do
		{
			while (--j);
		} while (--i);
		xms--;
	}
}
void main()
{
	unsigned char LEDNum;
	while(1)
	{
		if(P3_1==0)
		{
			Delay(20);
			while(P3_1==0);
			Delay(20);
			
			LEDNum++;
			P2=~LEDNum;
		}
	}
}
```
 **注：不能写“P2++；P2=~P2”由于单片机上电的时候，所有的IO口默认为高电平，所以P2默认为1111 1111，“P2++”后P2为0000 0000，再进行“P2=~P2”，此时P2为1111 1111，丝毫未变！！！**
 - 但可以写成“P2--”

# 独立按键控制LED移位
```c
#include <REGX52.H>
void Delay(unsigned int xms)	//@11.0592MHz
{
	unsigned char data i, j;
	while(xms--)
	{
		i = 2;
		j = 199;
		do
		{
			while (--j);
		} while (--i);
	}
}

void main()
{
	unsigned char LEDNum=0;
	P2=~(0x01);
	while(1)
	{
		if(P3_1==0)
		{
			Delay(20);
			while(P3_1==0);
			Delay(20);
			LEDNum++;
			if(LEDNum>=8)
			{
				LEDNum=0;
			}
			P2=~(0x01<<LEDNum);
		}
		if(P3_0==0)
		{
			Delay(20);
			while(P3_0==0);
			Delay(20);
			if(LEDNum==0)
			{
				LEDNum=7;
			}
			else
			{
				LEDNum--;
			}
			P2=~(0x01<<LEDNum);
		}
	}
}
```