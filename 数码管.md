# 数码管引脚定义
- 管脚定义（对应字母控制对应位置亮）：下图中位于上方的为共阴极、位于下方的为共阳极（可以理解为3,8管脚处为供电，三角形尖尖有一横的是负极，所有共阴极），两个图中的数字为引脚：
![](https://github.com/258-maker/picx-images-hosting/raw/master/xxx/IMG_20260207_100631.8dxdxwivmz.webp)
- **共阴极**（因为共阴极所有3、8号公共端要接地，即为0）连接显示数字6的操作，有电势差即有电流流过灯才会亮，所有下面的**1为亮，0不亮**：（位选：10111110：显示6），该八位数据为LED的段码。==**注意：本单片机的数码管为共阴极连接！！！**==
![](https://github.com/258-maker/picx-images-hosting/raw/master/xxx/IMG_20260207_101138.2a5lvggtd7.webp)
- **共阳极**，接VCC为1，**下面的为0才亮**，有电流流过，有电势差灯才亮：
![](https://github.com/258-maker/picx-images-hosting/raw/master/xxx/IMG_20260207_100816.96a9fn03hm.webp)
- **多个数码管**，PCB板的4个为一体，同样上面为共阴极、下面为共阳极的原理图：
![](https://github.com/258-maker/picx-images-hosting/raw/master/xxx/IMG_20260207_101501.70autv8fqb.webp)
- 共阴极，**公共端（12、9、8、6）接地（给0）才会亮**，即可以控制第几位亮；显示的数字则通过下面（11、7、4、2、1、10、5、3即对应字母ABCDEFG）控制，**给1才亮，给0不亮（电势差）**；下图显示结果：第三亮，显示数字1：
![](https://github.com/258-maker/picx-images-hosting/raw/master/xxx/IMG_20260207_101600.4ubg83grz9.webp)

# 138译码器
- 输入的3个口（ABC,读的时候是从下读 C B A ），控制输出的8个口，输出口连接共阴极的，是0还是1，在这里控制：
![](https://github.com/258-maker/picx-images-hosting/raw/master/xxx/1770431517485.5xb5izcluv.webp)
- 通过CBA给数字0和1二进制转换10进制（得到数字几）就控制Y几，**故选中Y几，该口就输出0，其他口均为1**；
![](https://github.com/258-maker/picx-images-hosting/raw/master/xxx/IMG_20260207_104354.8dxdxwjhra.webp)

|  C  |  B  |  A  |  Y  |
| :-: | :-: | :-: | :-: |
|  0  |  0  |  0  | Y0  |
|  0  |  0  |  1  | Y1  |
|  0  |  1  |  0  | Y2  |
|  0  |  1  |  1  | Y3  |
|  1  |  0  |  0  | Y4  |
|  1  |  0  |  1  | Y5  |
|  1  |  1  |  0  | Y6  |
|  1  |  1  |  1  | Y7  |

# 静态数码管显示
- 操作：通过P22~P24控制138译码器的A、B、C以此来选中哪个LED亮，此过程为**位选**；再通过P00~P07控制数码管a~g、dp这八个发光段的亮灭，此过程为**段选**；
- 数码管模块原理图：
![](https://github.com/258-maker/picx-images-hosting/raw/master/xxx/1770434615679.45i6o2t8yw.webp)
- 常用段码表：

| 显示数字 |  段码  | 显示数字 |  段码  |
| :--: | :--: | :--: | :--: |
|  0   | 0x3F |  5   | 0x6D |
|  1   | 0x06 |  6   | 0x7D |
|  2   | 0x5B |  7   | 0x07 |
|  3   | 0x4F |  8   | 0x7F |
|  4   | 0x66 |  9   | 0x6F |

```c
#include <REGX52.H>
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,0x00};
void Nixie(unsigned char Location,Number)
{
	switch(Location)
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0=NixieTable[Number];
}
void main()
{
	Nixie(7,9);
	while(1)
	{
		
	}
}
```
# 动态数码管显示
- 消影，动态数码管显示过程中会出现段选、位选影响造成串位的问题，需要消影，用如下代码消除：
```c
void Nixie(unsigned char Location,Number)
{
	switch(Location)
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0=NixieTable[Number];
	Delay(1);//消影关键
	P0=0x00;//消影关键
}
```

# 数码管从 0 到 9 每秒计数
```c
#include <REGX52.H>
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,0x00};
void Delay(unsigned int xms)	//@11.0592MHz
{
	unsigned char data i, j;
	while(xms--)
	{
		i = 2;
		j = 199;
		do
		{
			while (--j);
		} while (--i);
	}
}

void Nixie(unsigned char Location,Number)
{
	switch(Location)
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0=NixieTable[Number];
	Delay(1);
	P0=0x00;
}
void main()
{
	while(1)
	{
		unsigned int i,t;
		for(i=0;i<10;i++)
		{
			for(t=0;t<1000;t++)
			{
				Nixie(1,i);
			}	
		}
	}
}

```