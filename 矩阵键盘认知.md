**矩阵键盘**
> 在键盘中按键数量较多时，为了减少I/O口的占用，通常将按键排列成矩阵形式，采用逐行或逐列的“扫描”，就可以读出任何位置按键的状态。

**扫描**
- 数码管扫描（输出扫描）
> 显示第1位→显示第2位→显示第3位→……，然后快速循环这个过程，最终实现所有数码管同时显示的效果

- 矩阵键盘扫描（输入扫描）
> 读取第1行（列）→读取第2行（列）→读取第3行（列）→…… 然后快速循环这个过程，最终实现所有按键同时检测的效果

- 以上两种扫描方式的共性：节省I/O口

**列扫描矩阵键盘**
```c
unsigned char MatrixKey()
{
	unsigned KeyNumber=0;
	P1=0xFF;
	P1_3=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=1;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=5;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=9;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=13;}
	
	P1=0xFF;
	P1_2=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=2;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=6;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=10;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=14;}
	
	P1=0xFF;
	P1_1=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=3;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=7;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=11;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=15;}
	
	P1=0xFF;
	P1_0=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=4;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=8;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=12;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=16;}
	
	return KeyNumber;
}
```
- 逐列进行扫描，按键采用阻塞延迟消抖

**main函数代码部分**
```c
#include <REGX52.H>
#include "Delay.h"
#include "LCD1602.h"
#include "MatrixKey.h"
unsigned char KeyNum;
void main()
{
	LCD_Init();
	LCD_ShowString(1,1,"MatrixKey:");
	while(1)
	{
		KeyNum=MatrixKey();
		if(KeyNum!=0)
		{
			LCD_ShowNum(2,1,KeyNum,2);
		}
	
	}

}

```
- 上面代码中，while循环里必须要有if判断，因为当代码执行时，KeyNum会在按键按下后马上变为对应的值，又会快速变为0，在加上if条件后，虽然KeyNum依旧会快速变为0，但LCD所显示的数字不变，因为if的条件是KeyNum!=0,当KeyNum变为0时，相当于LCD所显示的数字被锁定了，因此LCD仍能显示相应的数字。