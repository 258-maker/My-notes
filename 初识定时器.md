# 中断系统
## 中断结构
- 八个中断请求源：外部中断（**INT0**（P3_2）、**INT1**（P3_3）、INT2、INT3），定时器（**TIM0**（P3_4）、**TIM1**（P3_5）、TIM2），串口**UART**（RX P3_0,TX P3_1）；
- 51单片机只学习上述加黑的五个中断请求源，以下表格中从上到下，优先级从高到低，但可以通过修改寄存器的值来改变优先级，但一般不修改


| 中断源符号 | 名称           | 中断引起原因                               | 中断号 |
| :------------: | :----------------: | :--------------------------------------------: | :--------: |
| /INT0      | 外部中断0      | P3.2引脚低电平或下降沿信号                 | 0      |
| T0         | 定时器0中断    | 定时/计数器0计数回0溢出                     | 1      |
| /INT1      | 外部中断1      | P3.3引脚低电平或下降沿信号                 | 2      |
| T1         | 定时器1中断    | 定时/计数器1计数回0溢出                     | 3      |
| TI/RI      | 串行口中断     | 串行通信完成一帧数据发送或接收引起中断       | 4      |


- INT0这一行中：IT0掷1（下降沿触发），掷0（低电平触发）；IE0（中断标志）当中断事件来临，IE0会**自动**置1；EX0（外部中断选择位），要使能外部中断的话，EX0要置1，即开关闭合；EA（全局总中断），置1开关闭合；IP（设置中断优先级），默认接0；
- T0这一行中：TF0（溢出请求标志），当有溢出请求时，TF0会**自动**置1，接下来的过程与INT0一致；
- RX、TX：RI（接收完成标志）、TI（发送完成标志）、“>=1”（或门），当RI或TI有一个为1时（**自动**），即会发送中断请求
==总结：TCON和SCON这两个寄存器当中断事件来临时，会自动置1或0（IT0和IT1需配置）；IE、IP寄存器中的标志位则需我们进行配置；==

## 中断寄存器
1. 中断允许控制

| 位        | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |     |
| -------- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 字节地址：A8H | EA  | -   | -   | ES  | ET1 | EX1 | ET0 | EX0 | IE  |
2. 中断请求标志 TCON

| 位        | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |      |
| -------- | --- | --- | --- | --- | --- | --- | --- | --- | ---- |
| 字节地址：88H | TF1 | TR1 | TF0 | TR0 | IE1 | IT1 | IE0 | IT0 | TCON |

- IE（中断允许控制）中：EA为总中断，ES（串口中断允许位），ET1、ET0（TIM1、TIM0的中断允许位），EX0、EX1（INT0，INT1的中断允许位）
- TCON（中断请求标志）中：IT0、IT1（INT0、INT1的触发方式控制位），IE0、IE1（INT0、INT1的请求标志位）当中断事件来临时会自动置1，TR0、TR1（T0、T1的溢出中断请求标志位）发生溢出时会自动置1

**中断响应条件**
1. 中断源有中断请求；
2. 中断源的中断允许位为1；
3. CPU开中断（即EA=1）；

# 定时器
## 定时器介绍
> 定时器在单片机内部就像一个小闹钟一样，根据时钟的输出信号，每隔 “一秒”，计数单元的数值就增加一，当计数单元数值增加到 “设定的闹钟提醒时间” 时，计数单元就会向中断系统发出中断申请，产生 “响铃提醒”，使程序跳转到中断服务函数中执行。
- 时钟：提供计数单元的时钟脉冲
- 计数单元：时钟计数
- 中断系统：产生中断，执行定时任务

CPU时序的有关知识：
1. 振荡周期：假设晶振频率为12MHz，那么周期为频率的倒数，1/12us即为振荡周期；
2. 状态周期：2个振荡周期；
3. 机器周期：6个状态周期；
4. 指令周期：1~4个机器周期
- 例如：外接晶振为12MHz时，51单片机相关周期的具体值为：振荡周期=1/12us；状态周期=1/6us；机器周期=1us；指令周期为1~4us
## 定时/计数器结构
1. 工作方式TMOD

| 位        | 7    | 6    | 5   | 4   | 3    | 2    | 1   | 0   |      |
| -------- | ---- | ---- | --- | --- | ---- | ---- | --- | --- | ---- |
| 字节地址：89H | GATE | C/T̄ | M1  | M0  | GATE | C/T̄ | M1  | M0  | TMOD |
2. TMOD 工作方式说明

| M1M0 | 工作方式 | 说明                                         |
|------|----------|----------------------------------------------|
| 00   | 方式0    | 13位定时/计数器                              |
| 01   | 方式1    | 16位定时/计数器                              |
| 10   | 方式2    | 8位自动重装定时/计数器                       |
| 11   | 方式3    | T0分成两个独立的8位定时/计数器；T1此方式停止计数 |
- GATE：用来设置门控位，设置定时器启动是否受外部信号的影响，GATE=0时，那么只要用软件来将TR0或TR1（这两个标志位位于TCON这个寄存器）设置为1，即可开启对应定时器工作；GATE=1时除了软件来将TR0或TR1设置为1外，还要INT0或INT1为高电平才能启动定时器工作
- C/T：用于定时/计数器模式的选择，设置为0时为定时模式，设置为1时为计数模式
- M1、M0：工作方式的设置，4种工作方式如上图，方式1通常是定时计数器的工作，方式2通常是用来生成串口波特率
**注：高四位（4~7）用来管理T1，低四位（0~3）用来管理T0**
3. 控制寄存器 TCON

| 位        | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |      |
| -------- | --- | --- | --- | --- | --- | --- | --- | --- | ---- |
| 字节地址：88H | TF1 | TR1 | TF0 | TR0 | -   | -   | -   | -   | TCON |
- 外部中断通过TCON的低四位来控制，定时器则主要通过高四位来控制
- TF0/TF1:定时/计数器溢出中断标志位，溢出后自动置1，CPU读取后自动置0
- TR0/TR1：定时/计数器的运行控制标志位，置1时开始工作，置0时停止工作

## 以 1ms 定时为例的定时器初值计算过程
==时间=定时的次数（溢出值-初始值）X 机械周期==
- 计算机械周期，晶振频率（Fosc）为11.0592MHz，（12 X 1/11.0592）us≈ 1.085069444 us；时间为1ms，即1000us；溢出值为65536；
- 定时的次数=1000/1.085069444≈ 921.60000037748
- 初始值=65536-921.60000037748=64614.399999622（0xFC66）
**故初始约值为0xFC66**

## 定时器配置
1. 对TMOD赋值，以确定T0和T1的工作方式、工作模式
2. 根据所要定时的时间计算初值，并将其写入TH0、TL0或TH1、TL1
3. 如果使用中断，则对EA赋值，开放定时器中断
4. 使TR0或TR1置位，启动定时/计数器定时或计数
```c
void time0_init(void)
{
	TMOD|=0x01;//选择为定时器0模式，工作方式1
	TH0=0xFC;//给定时器赋初值，定时1ms
	TL0=0x66;
	ET0=1;//打开定时器0中断允许
	EA=1;//打开总中断
	TR0=1;//打开定时器
}
```
TMOD为不可位操作，运用 |（或预算），方便我们对TMOD的值进行设置时不干扰其他的高四位

**定时器控制 LED 闪烁（1 秒闪一次）代码**
```c
#include <REGX52.H>
void Time0_Init(void);
void main()
{
	Time0_Init();
	while(1)
	{
		
	}
}

void Time0_Init(void)
{
	TMOD|=0x01;
	TH0=0xFC;
	TL0=0x66;
	TR0=1;
	ET0=1;
	EA=1;
}

void My_Time0() interrupt 1
{
	static unsigned int i=0;//要设置静态变量static，让i保存上一次的值
	TH0=0xFC;//工作方式1不像工作方式2那样能自动重装初值，所以需要写程序手动重装初值
	TL0=0x66;
	i++;
	if(i==1000)
	{
		P2_0=~P2_0;
		i=0;
	}
}
```
注：
- 工作方式1不像工作方式2那样能自动重装初值，所以需要写程序手动重装初值
- 要设置静态变量static，让i保存上一次的值

